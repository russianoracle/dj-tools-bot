name: CI/CD Multi-Stage

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
  workflow_run:
    workflows: ["Build Base Image"]
    types: [completed]
    branches: [main]

env:
  REGISTRY: cr.yandex
  REGISTRY_ID: crp78hhr2t67jkeedad1
  IMAGE_NAME: mood-classifier
  PYTHON_VERSION: "3.12"
  SHARED_BUILDER: ci-shared-builder
  GH_BIN: /opt/homebrew/bin/gh

jobs:
  # ===========================================================================
  # Job 1: Setup Shared Builder
  # ===========================================================================
  setup-builder:
    name: Setup Shared Builder
    runs-on: self-hosted
    steps:
      - name: Create or reuse shared builder
        run: |
          if ! docker buildx inspect ${{ env.SHARED_BUILDER }} >/dev/null 2>&1; then
            echo "Creating new shared builder: ${{ env.SHARED_BUILDER }}"
            docker buildx create \
              --name ${{ env.SHARED_BUILDER }} \
              --driver docker-container \
              --driver-opt network=host \
              --buildkitd-flags '--oci-worker-gc=false' \
              --bootstrap
          else
            echo "Shared builder already exists: ${{ env.SHARED_BUILDER }}"
          fi
          docker buildx use ${{ env.SHARED_BUILDER }}
          docker buildx inspect --bootstrap

  # ===========================================================================
  # Job 2: Security Scan
  # ===========================================================================
  security:
    name: Security Scan
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4

      - name: Cleanup gitleaks temp files
        run: rm -f /tmp/gitleaks.tmp /tmp/gitleaks_8.24.3_linux_x64.tar.gz
        continue-on-error: true

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_ENABLE_UPLOAD_ARTIFACT: false
          GITLEAKS_ENABLE_SUMMARY: false

  # ===========================================================================
  # Job 3: Build & Test
  # ===========================================================================
  build-and-test:
    name: Build & Test
    runs-on: self-hosted
    needs: setup-builder
    # Run immediately after setup-builder, don't wait for security
    steps:
      - uses: actions/checkout@v4

      - name: Login to registry (for cache pull only)
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login \
            ${{ env.REGISTRY }} \
            --username json_key \
            --password-stdin

      - name: Use shared builder
        run: docker buildx use ${{ env.SHARED_BUILDER }}

      - name: Pull previous image for layer cache
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest 2>/dev/null || \
          echo "No previous image, building from scratch"

      - name: Pull base image for cache
        run: |
          BASE_IMAGE="${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/app-base:${{ env.PYTHON_VERSION }}"
          docker pull "$BASE_IMAGE" 2>/dev/null || echo "Base image pull failed, will build from scratch"

      - name: Build test stage (includes app + test deps)
        run: |
          docker buildx build \
            --builder ${{ env.SHARED_BUILDER }} \
            --target test \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg REGISTRY=${{ env.REGISTRY }} \
            --build-arg REGISTRY_ID=${{ env.REGISTRY_ID }} \
            --cache-from type=registry,ref=${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache,mode=max \
            --output type=docker,name=mood-classifier:test-${{ github.sha }} \
            --file Dockerfile.unified \
            .

          echo "Test image built and loaded to Docker daemon"
          docker images | grep mood-classifier

      - name: Run container dependency tests
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            -e DATA_DIR=/data \
            -e DOWNLOADS_DIR=/tmp/downloads \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/test_ci_container.py -v --tb=short

      - name: Start Redis for integration tests
        run: |
          docker rm -f test-redis 2>/dev/null || true
          docker run -d --name test-redis -p 6379:6379 redis:7-alpine
          sleep 2

      - name: Run integration tests with Redis
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            --network host \
            -e REDIS_HOST=localhost \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/test_ci_cache_redis.py -v --tb=short

      - name: Run pipeline tests (real audio)
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            -v $(pwd)/tests/fixtures:/app/tests/fixtures \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/test_ci_pipelines.py -v --tb=short

      - name: Cleanup Redis
        if: always()
        run: docker rm -f test-redis 2>/dev/null || true

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }} || true

  # ===========================================================================
  # Job 4: Push Production Image
  # ===========================================================================
  push-production:
    name: Push Production Image
    runs-on: self-hosted
    needs: build-and-test
    if: |
      success() && (
        (github.event_name == 'push' && github.ref == 'refs/heads/main') ||
        (github.event_name == 'workflow_run' && github.event.workflow_run.head_branch == 'main') ||
        github.event_name == 'workflow_dispatch'
      )
    steps:
      - uses: actions/checkout@v4

      - name: Login to registry
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login \
            ${{ env.REGISTRY }} \
            --username json_key \
            --password-stdin

      - name: Use shared builder
        run: docker buildx use ${{ env.SHARED_BUILDER }}

      - name: Build production stage and push
        run: |
          echo "Building production stage (reuses layers from test build)"

          docker buildx build \
            --builder ${{ env.SHARED_BUILDER }} \
            --target production \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg REGISTRY=${{ env.REGISTRY }} \
            --build-arg REGISTRY_ID=${{ env.REGISTRY_ID }} \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --push \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            --file Dockerfile.unified \
            .

          echo "Production image pushed to registry"

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }} || true

  # ===========================================================================
  # Job 5: Cleanup Local Cache
  # ===========================================================================
  cleanup:
    name: Cleanup Local Cache
    runs-on: self-hosted
    needs: deploy
    if: always()
    steps:
      - name: Clean old local test images
        run: |
          echo "Cleaning old local test images (keeping last 2)"

          docker images --format "{{.Repository}}:{{.Tag}}" | \
            grep "mood-classifier:test-" | \
            tail -n +3 | \
            xargs -r docker rmi -f || true

          docker image prune -f

          echo "Cleanup complete"

      - name: Verify BuildKit cache size
        run: |
          if [ -d /tmp/.buildx-cache ]; then
            cache_size=$(du -sh /tmp/.buildx-cache | cut -f1)
            echo "BuildKit cache size: $cache_size"

            size_bytes=$(du -sb /tmp/.buildx-cache | cut -f1)
            if [ $size_bytes -gt 16000000000 ]; then
              echo "Cache is very large (>15GB), consider clearing"
            fi
          fi

  # ===========================================================================
  # Job 6: Deploy to VM
  # ===========================================================================
  deploy:
    name: Deploy to VM
    runs-on: self-hosted
    needs: push-production
    # No conditional - fetch-secrets.sh has built-in defaults
    steps:
      - uses: actions/checkout@v4

      - name: Fetch secrets from Lockbox
        run: |
          # Use fetch-secrets.sh script (has built-in defaults)
          if [ -f "./scripts/fetch-secrets.sh" ]; then
            chmod +x ./scripts/fetch-secrets.sh
            ./scripts/fetch-secrets.sh --env-file /home/ubuntu/app/.env
          else
            echo "ERROR: scripts/fetch-secrets.sh not found"
            exit 1
          fi

      - name: Login to YC registry
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login \
            ${{ env.REGISTRY }} \
            --username json_key \
            --password-stdin

      - name: Deploy containers
        run: |
          echo "=== Deploying containers ==="

          # Save checkout directory
          CHECKOUT_DIR="$(pwd)"
          echo "Checkout directory: $CHECKOUT_DIR"

          # Pull new image (YC registry only, no Docker Hub fallback)
          docker pull ${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest

          # Go to production directory
          cd /home/ubuntu/app

          # Copy configuration files from checkout to production BEFORE stopping containers
          echo "Copying configuration files from $CHECKOUT_DIR to /home/ubuntu/app/..."
          cp "$CHECKOUT_DIR/docker-compose.yml" /home/ubuntu/app/ && echo "âœ… docker-compose.yml" || echo "âŒ ERROR: docker-compose.yml not found!"
          cp "$CHECKOUT_DIR/fluent-bit.conf" /home/ubuntu/app/ 2>/dev/null && echo "âœ… fluent-bit.conf" || echo "âš ï¸  fluent-bit.conf not found"
          cp "$CHECKOUT_DIR/parsers.conf" /home/ubuntu/app/ 2>/dev/null && echo "âœ… parsers.conf" || echo "âš ï¸  parsers.conf not found"
          cp "$CHECKOUT_DIR/set-source.lua" /home/ubuntu/app/ 2>/dev/null && echo "âœ… set-source.lua" || echo "âš ï¸  set-source.lua not found"
          cp "$CHECKOUT_DIR/flatten-log.lua" /home/ubuntu/app/ 2>/dev/null && echo "âœ… flatten-log.lua" || echo "âš ï¸  flatten-log.lua not found"
          cp "$CHECKOUT_DIR/healthcheck_worker.py" /home/ubuntu/app/ 2>/dev/null && echo "âœ… healthcheck_worker.py" || echo "âš ï¸  healthcheck_worker.py not found"
          cp "$CHECKOUT_DIR/logging-config.yaml" /home/ubuntu/app/ 2>/dev/null && echo "âœ… logging-config.yaml" || echo "âš ï¸  logging-config.yaml not found"

          # Copy scripts directory (all scripts automatically)
          mkdir -p /home/ubuntu/app/scripts
          rsync -av --delete "$CHECKOUT_DIR/scripts/" /home/ubuntu/app/scripts/ 2>/dev/null && echo "âœ… scripts/" || echo "âš ï¸  scripts/ not found"
          chmod +x /home/ubuntu/app/scripts/*.sh /home/ubuntu/app/scripts/*.py 2>/dev/null || true

          # Stop and REMOVE containers to force recreate with new config
          echo "Stopping and removing containers to apply new configuration..."
          docker-compose down --remove-orphans || true

          # Start all services with docker-compose (--force-recreate ensures new config is applied)
          echo "Starting containers with new configuration..."
          docker-compose up -d --force-recreate

          # Verify containers are running
          sleep 10
          docker-compose ps

          # Check logs for startup errors
          echo ""
          echo "=== Bot startup logs ==="
          docker-compose logs --tail 20 bot

          echo ""
          echo "=== Fluent-bit logs ==="
          docker-compose logs --tail 20 fluent-bit

          echo ""
          echo "âœ… Deployment successful"

  # ===========================================================================
  # Job 7: Cleanup Old Docker Images (parallel after deploy)
  # ===========================================================================
  cleanup-docker-images:
    name: Cleanup Old Docker Images
    runs-on: self-hosted
    needs: deploy
    if: always()
    steps:
      - name: Clean old local test images
        run: |
          echo "ðŸ§¹ Cleaning old Docker images (keeping last 2)..."

          docker images --format "{{.Repository}}:{{.Tag}}" | \
            grep "mood-classifier:test-" | \
            tail -n +3 | \
            xargs -r docker rmi -f || true

          docker image prune -f

          echo "âœ… Docker image cleanup complete"

  # ===========================================================================
  # Job 8: Cleanup Old Logs (parallel after deploy)
  # ===========================================================================
  cleanup-logs:
    name: Cleanup Old Logs
    runs-on: self-hosted
    needs: deploy
    if: always()
    steps:
      - name: Remove old Docker logs
        run: |
          echo "ðŸ§¹ Cleaning up old logs (>2 days)..."

          # Remove old Docker logs (>2 days)
          find /var/lib/docker/containers -name "*.log" -mtime +2 -delete 2>/dev/null || true

          # Check cache size
          if [ -d /tmp/.buildx-cache ]; then
            cache_size=$(du -sh /tmp/.buildx-cache | cut -f1)
            echo "BuildKit cache size: $cache_size"

            size_bytes=$(du -sb /tmp/.buildx-cache | cut -f1)
            if [ $size_bytes -gt 16000000000 ]; then
              echo "âš ï¸ Cache is very large (>15GB), consider clearing"
            fi
          fi

          echo "âœ… Log cleanup complete"

  # ===========================================================================
  # Job 9: Cleanup Downloads Directory (parallel after deploy)
  # ===========================================================================
  cleanup-downloads:
    name: Cleanup Downloads Directory
    runs-on: self-hosted
    needs: deploy
    if: always()
    steps:
      - name: Clean downloads and system cache
        run: |
          echo "ðŸ§¹ Cleaning downloads directory and system cache..."

          # Clean downloads if it exists
          if [ -d /tmp/downloads ]; then
            rm -rf /tmp/downloads/* 2>/dev/null || true
            echo "Cleaned /tmp/downloads"
          fi

          # Clean Docker system (unused images, containers, networks)
          docker system prune -f --volumes || true

          # Clean package cache
          sudo apt-get clean 2>/dev/null || true

          echo "âœ… Downloads and cache cleanup complete"

  # ===========================================================================
  # Job 10: Cleanup Registry (runs after all parallel cleanups complete)
  # ===========================================================================
  cleanup-registry:
    name: Cleanup Registry
    runs-on: self-hosted
    needs: [cleanup, cleanup-docker-images, cleanup-logs, cleanup-downloads]
    if: always() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Cleanup old images in registry (keep last 3)
        run: |
          echo "Cleaning old images from registry (keeping last 3)"

          # Check if yc is available
          if ! command -v yc &> /dev/null; then
            echo "yc CLI not found, skipping registry cleanup"
            exit 0
          fi

          # Step 1: Delete all untagged images immediately
          echo "Deleting untagged images..."
          yc container image list \
            --registry-id ${{ env.REGISTRY_ID }} \
            --format json 2>/dev/null | \
          jq -r '.[] | select(.tags | length == 0) | .id' | \
          while read image_id; do
            if [ -n "$image_id" ]; then
              echo "Deleting untagged image: $image_id"
              yc container image delete --id "$image_id" 2>/dev/null || true
            fi
          done

          # Step 2: Keep only last 3 SHA-tagged images (sort by date, newest first)
          echo "Cleaning old SHA-tagged images (keeping last 3)..."
          yc container image list \
            --registry-id ${{ env.REGISTRY_ID }} \
            --format json 2>/dev/null | \
          jq -r '.[] | select(.tags | length > 0 and (.[0] | contains("latest") | not)) |
                 "\(.created_at) \(.id)"' | \
          sort -r | \
          awk '{print $2}' | \
          tail -n +4 | \
          while read image_id; do
            if [ -n "$image_id" ]; then
              echo "Deleting old image: $image_id"
              yc container image delete --id "$image_id" 2>/dev/null || true
            fi
          done

          echo "âœ… Registry cleanup complete"
