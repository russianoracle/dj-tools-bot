name: CI/CD Multi-Stage

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: cr.yandex
  IMAGE_NAME: mood-classifier
  PYTHON_VERSION: "3.12"
  SHARED_BUILDER: ci-shared-builder

jobs:
  # ===========================================================================
  # Job 1: Setup Shared Builder
  # ===========================================================================
  setup-builder:
    name: Setup Shared Builder
    runs-on: self-hosted
    steps:
      - name: Create or reuse shared builder
        run: |
          if ! docker buildx inspect ${{ env.SHARED_BUILDER }} >/dev/null 2>&1; then
            echo "Creating new shared builder: ${{ env.SHARED_BUILDER }}"
            docker buildx create \
              --name ${{ env.SHARED_BUILDER }} \
              --driver docker-container \
              --driver-opt network=host \
              --buildkitd-flags '--oci-worker-gc=false' \
              --bootstrap
          else
            echo "Shared builder already exists: ${{ env.SHARED_BUILDER }}"
          fi
          docker buildx use ${{ env.SHARED_BUILDER }}
          docker buildx inspect --bootstrap

  # ===========================================================================
  # Job 2: Security Scan
  # ===========================================================================
  security:
    name: Security Scan
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_ENABLE_UPLOAD_ARTIFACT: false
          GITLEAKS_ENABLE_SUMMARY: false

  # ===========================================================================
  # Job 3: Build & Test
  # ===========================================================================
  build-and-test:
    name: Build & Test
    runs-on: self-hosted
    needs: [setup-builder, security]
    if: always()
    steps:
      - uses: actions/checkout@v4

      - name: Login to registry (for cache pull only)
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login \
            ${{ env.REGISTRY }} \
            --username json_key \
            --password-stdin

      - name: Use shared builder
        run: docker buildx use ${{ env.SHARED_BUILDER }}

      - name: Pull previous image for layer cache
        run: |
          docker pull ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest 2>/dev/null || \
          echo "No previous image, building from scratch"

      - name: Pull base image for cache
        run: |
          BASE_IMAGE="${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/app-base:${{ env.PYTHON_VERSION }}"
          docker pull "$BASE_IMAGE" 2>/dev/null || echo "Base image pull failed, will build from scratch"

      - name: Build test stage (includes app + test deps)
        run: |
          docker buildx build \
            --builder ${{ env.SHARED_BUILDER }} \
            --target test \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg REGISTRY=${{ env.REGISTRY }} \
            --build-arg REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }} \
            --cache-from type=registry,ref=${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache,mode=max \
            --output type=docker,name=mood-classifier:test-${{ github.sha }} \
            --file Dockerfile.unified \
            .

          echo "Test image built and loaded to Docker daemon"
          docker images | grep mood-classifier

      - name: Run container dependency tests
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            -e DATA_DIR=/data \
            -e DOWNLOADS_DIR=/tmp/downloads \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/test_ci_container.py -v --tb=short || true

      - name: Start Redis for integration tests
        run: |
          docker rm -f test-redis 2>/dev/null || true
          docker run -d --name test-redis -p 6379:6379 redis:7-alpine
          sleep 2

      - name: Run integration tests with Redis
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            --network host \
            -e REDIS_HOST=localhost \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/test_ci_cache_redis.py -v --tb=short || true

      - name: Run pipeline tests (real audio)
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            -v $(pwd)/tests/fixtures:/app/tests/fixtures \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/test_ci_pipelines.py -v --tb=short || true

      - name: Cleanup Redis
        if: always()
        run: docker rm -f test-redis 2>/dev/null || true

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }} || true

  # ===========================================================================
  # Job 4: Push Production Image
  # ===========================================================================
  push-production:
    name: Push Production Image
    runs-on: self-hosted
    needs: build-and-test
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Login to registry
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login \
            ${{ env.REGISTRY }} \
            --username json_key \
            --password-stdin

      - name: Use shared builder
        run: docker buildx use ${{ env.SHARED_BUILDER }}

      - name: Build production stage and push
        run: |
          echo "Building production stage (reuses layers from test build)"

          docker buildx build \
            --builder ${{ env.SHARED_BUILDER }} \
            --target production \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg REGISTRY=${{ env.REGISTRY }} \
            --build-arg REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }} \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --push \
            -t ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            --file Dockerfile.unified \
            .

          echo "Production image pushed to registry"

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }} || true

  # ===========================================================================
  # Job 5: Cleanup Local Cache
  # ===========================================================================
  cleanup:
    name: Cleanup Local Cache
    runs-on: self-hosted
    needs: [push-production]
    if: always()
    steps:
      - name: Clean old local test images
        run: |
          echo "Cleaning old local test images (keeping last 2)"

          docker images --format "{{.Repository}}:{{.Tag}}" | \
            grep "mood-classifier:test-" | \
            tail -n +3 | \
            xargs -r docker rmi -f || true

          docker image prune -f

          echo "Cleanup complete"

      - name: Verify BuildKit cache size
        run: |
          if [ -d /tmp/.buildx-cache ]; then
            cache_size=$(du -sh /tmp/.buildx-cache | cut -f1)
            echo "BuildKit cache size: $cache_size"

            size_bytes=$(du -sb /tmp/.buildx-cache | cut -f1)
            if [ $size_bytes -gt 16000000000 ]; then
              echo "Cache is very large (>15GB), consider clearing"
            fi
          fi

  # ===========================================================================
  # Job 6: Deploy to VM
  # ===========================================================================
  deploy:
    name: Deploy to VM
    runs-on: self-hosted
    needs: push-production
    if: success() && vars.YC_LOCKBOX_SECRET_ID != ''
    steps:
      - name: Fetch secrets from Lockbox
        run: |
          echo "=== Fetching secrets from Yandex Lockbox ==="

          # Get IAM token from metadata service
          export IAM_TOKEN=$(curl -sf -H 'Metadata-Flavor: Google' \
            http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token \
            | jq -r '.access_token')

          if [ -z "$IAM_TOKEN" ]; then
            echo "ERROR: Failed to get IAM token"
            exit 1
          fi
          echo "✅ IAM token obtained"

          # Fetch secrets from Lockbox
          SECRET_ID="${{ secrets.YC_LOCKBOX_SECRET_ID }}"
          if [ -z "$SECRET_ID" ]; then
            echo "⚠️  YC_LOCKBOX_SECRET_ID not configured, skipping Lockbox fetch"
            echo "Using manual secret configuration instead"
            exit 0
          fi
          SECRETS=$(/opt/yc/bin/yc lockbox payload get --id "$SECRET_ID" --format json)

          SECRET_COUNT=$(echo "$SECRETS" | jq -r '.entries | length')
          echo "✅ Found $SECRET_COUNT secrets in Lockbox"

          # Write to .env file
          ENV_FILE="/opt/mood-classifier/.env"
          mkdir -p /opt/mood-classifier

          echo "# Auto-generated from Yandex Lockbox" > "$ENV_FILE"
          echo "# Secret: ${SECRET_ID:0:8}..." >> "$ENV_FILE"
          echo "# Generated: $(date -Iseconds)" >> "$ENV_FILE"
          echo "" >> "$ENV_FILE"

          echo "$SECRETS" | jq -r '.entries[] | "\(.key)=\(.text_value)"' >> "$ENV_FILE"

          # Add static infrastructure vars
          cat >> "$ENV_FILE" << 'ENVEOF'

          # Infrastructure
          DATA_DIR=/data
          DOWNLOADS_DIR=/data/downloads
          REDIS_HOST=localhost
          REDIS_PORT=6379
          LOG_LEVEL=INFO
          LOG_JSON_FORMAT=true
          REQUIRE_SECRETS=true

          # Yandex Cloud
          YC_FOLDER_ID=${{ secrets.YC_FOLDER_ID }}
          YC_LOCKBOX_SECRET_ID=${{ secrets.YC_LOCKBOX_SECRET_ID }}
          ENVEOF

          chmod 600 "$ENV_FILE"
          echo "✅ Secrets written to $ENV_FILE"

          # Validate required secrets
          source "$ENV_FILE"
          if [ -z "$TELEGRAM_BOT_TOKEN" ]; then
            echo "❌ ERROR: TELEGRAM_BOT_TOKEN not found in Lockbox"
            exit 1
          fi
          echo "✅ TELEGRAM_BOT_TOKEN validated"

      - name: Deploy containers
        run: |
          echo "=== Deploying containers ==="

          # Pull new image
          docker pull ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest

          # Stop and remove old containers
          docker stop mood-classifier mood-arq-worker 2>/dev/null || true
          docker rm mood-classifier mood-arq-worker 2>/dev/null || true

          # Start bot container with env file from Lockbox
          docker run -d \
            --name mood-classifier \
            --restart unless-stopped \
            --network host \
            -v mood-data:/data \
            --env-file /opt/mood-classifier/.env \
            --health-cmd="python -c 'import sys; sys.exit(0)'" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-start-period=10s \
            --health-retries=3 \
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            python -m app.main

          # Start ARQ worker container
          docker run -d \
            --name mood-arq-worker \
            --restart unless-stopped \
            --network host \
            -v mood-data:/data \
            --env-file /opt/mood-classifier/.env \
            --health-cmd="python -c 'import sys; sys.exit(0)'" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-start-period=10s \
            --health-retries=3 \
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            arq app.services.arq_worker.WorkerSettings

          # Verify containers are running
          sleep 5
          docker ps | grep -E "mood-classifier|mood-arq-worker"

          # Check logs for startup errors
          echo ""
          echo "=== Bot startup logs ==="
          docker logs mood-classifier --tail 20

          echo ""
          echo "✅ Deployment successful"

  # ===========================================================================
  # Job 7: Cleanup Registry
  # ===========================================================================
  cleanup-registry:
    name: Cleanup Registry
    runs-on: self-hosted
    needs: [cleanup, deploy]
    if: always() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Cleanup old images in registry (keep last 5)
        run: |
          echo "Cleaning old images from registry (keeping last 5)"

          # Check if yc is available
          if ! command -v yc &> /dev/null; then
            echo "yc CLI not found, skipping registry cleanup"
            exit 0
          fi

          yc container image list \
            --registry-id ${{ secrets.YC_REGISTRY_ID }} \
            --format json 2>/dev/null | \
          jq -r '.[] | select(.tags | length == 0 or (.[0] | contains("latest") | not)) | .id' | \
          tail -n +6 | \
          while read image_id; do
            if [ -n "$image_id" ]; then
              echo "Deleting image: $image_id"
              yc container image delete --id "$image_id" 2>/dev/null || true
            fi
          done

          echo "Registry cleanup complete"
