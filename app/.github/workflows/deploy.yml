name: CI/CD Multi-Stage

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: cr.yandex
  IMAGE_NAME: mood-classifier
  PYTHON_VERSION: "3.12"
  SHARED_BUILDER: ci-shared-builder

jobs:
  # ============================================
  # JOB 1: Setup Shared Builder (idempotent)
  # ============================================
  setup-builder:
    name: Setup Shared Builder
    runs-on: self-hosted
    steps:
      - name: Create or reuse shared builder
        run: |
          if ! docker buildx inspect ${{ env.SHARED_BUILDER }} >/dev/null 2>&1; then
            echo "ðŸ”§ Creating new shared builder: ${{ env.SHARED_BUILDER }}"
            docker buildx create \
              --name ${{ env.SHARED_BUILDER }} \
              --driver docker-container \
              --driver-opt network=host \
              --buildkitd-flags '--oci-worker-gc=false' \
              --bootstrap
          else
            echo "âœ“ Shared builder already exists: ${{ env.SHARED_BUILDER }}"
          fi
          docker buildx use ${{ env.SHARED_BUILDER }}
          docker buildx inspect --bootstrap

  # ============================================
  # JOB 2: Security Scan (parallel with build-and-test)
  # ============================================
  security:
    name: Security Scan
    runs-on: self-hosted
    # Run in parallel with build-and-test, no dependencies
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Gitleaks
        run: |
          if ! command -v gitleaks &> /dev/null; then
            echo "ðŸ“¥ Installing gitleaks..."
            wget -q https://github.com/gitleaks/gitleaks/releases/download/v8.18.4/gitleaks_8.18.4_linux_x64.tar.gz
            tar -xzf gitleaks_8.18.4_linux_x64.tar.gz -C /tmp
            sudo mv /tmp/gitleaks /usr/local/bin/
            rm gitleaks_8.18.4_linux_x64.tar.gz
          fi
          gitleaks version

      - name: Run Gitleaks scan
        continue-on-error: true
        run: |
          echo "ðŸ” Scanning for secrets..."
          gitleaks detect --source . --verbose --no-git --exit-code 0
          echo "âœ… Security scan completed"

  # ============================================
  # JOB 3: Build Test Image (ONCE, shared by all test jobs)
  # ============================================
  build-test-image:
    name: Build Test Image
    runs-on: self-hosted
    needs: [setup-builder]
    steps:
      - uses: actions/checkout@v4

      - name: Login to registry (for cache pull only)
        run: echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

      - name: Use shared builder
        run: docker buildx use ${{ env.SHARED_BUILDER }}

      - name: Pull previous image for layer cache
        run: |
          docker pull ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest 2>/dev/null || \
          echo "âš ï¸ No previous image, building from scratch"

      - name: Pull base image for cache
        run: |
          BASE_IMAGE="${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/python-scientific:${{ env.PYTHON_VERSION }}"

          echo "ðŸ”„ Pulling latest base image: $BASE_IMAGE"
          docker pull "$BASE_IMAGE" 2>/dev/null || echo "âš ï¸ Base image pull failed, will build from scratch"

          # Show base image creation date to verify freshness
          if docker image inspect "$BASE_IMAGE" >/dev/null 2>&1; then
            CREATED=$(docker inspect "$BASE_IMAGE" --format='{{.Created}}')
            echo "ðŸ“… Base image created: $CREATED"
          fi

      - name: Build test stage (includes app + test deps)
        run: |
          docker buildx build \
            --builder ${{ env.SHARED_BUILDER }} \
            --target test \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg REGISTRY=${{ env.REGISTRY }} \
            --build-arg REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }} \
            --cache-from type=registry,ref=${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache,mode=max \
            --output type=docker,name=mood-classifier:test-${{ github.sha }} \
            --file Dockerfile.unified \
            .

          echo "âœ“ Test image built and loaded to Docker daemon"
          docker images | grep mood-classifier

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # ============================================
  # JOB 4: Run Tests in Parallel (matrix strategy)
  # ============================================
  test:
    name: Test (${{ matrix.test-type }})
    runs-on: self-hosted
    needs: [build-test-image]
    strategy:
      fail-fast: false  # Continue all tests even if one fails
      matrix:
        test-type: [unit, integration, analysis]
    steps:
      - uses: actions/checkout@v4

      - name: Start Redis (integration tests only)
        if: matrix.test-type == 'integration'
        run: |
          docker run -d --name test-redis-${{ github.sha }} -p 6379:6379 redis:7-alpine
          sleep 2

      - name: Run ${{ matrix.test-type }} tests
        run: |
          echo "ðŸ§ª Running ${{ matrix.test-type }} tests..."

          if [ "${{ matrix.test-type }}" = "integration" ]; then
            # Integration tests need Redis access
            docker run --rm \
              -v $(pwd)/tests:/app/tests \
              --network host \
              mood-classifier:test-${{ github.sha }} \
              pytest tests/ -m "${{ matrix.test-type }}" -vv --tb=short
          else
            # Unit and analysis tests run isolated
            docker run --rm \
              -v $(pwd)/tests:/app/tests \
              mood-classifier:test-${{ github.sha }} \
              pytest tests/ -m "${{ matrix.test-type }}" -vv --tb=short
          fi

      - name: Cleanup Redis
        if: always() && matrix.test-type == 'integration'
        run: docker rm -f test-redis-${{ github.sha }} || true

  # ============================================
  # JOB 5: Build & Push Production (AFTER TESTS + SECURITY)
  # ============================================
  push-production:
    name: Push Production Image
    runs-on: self-hosted
    needs: [test, security]  # Wait for ALL tests (matrix) AND security
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Login to registry
        run: echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

      - name: Use shared builder
        run: docker buildx use ${{ env.SHARED_BUILDER }}

      - name: Build production stage and push
        run: |
          echo "ðŸš€ Building production stage (reuses layers from test build)"

          docker buildx build \
            --builder ${{ env.SHARED_BUILDER }} \
            --target production \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg REGISTRY=${{ env.REGISTRY }} \
            --build-arg REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }} \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --push \
            -t ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            --file Dockerfile.unified \
            .

          echo "âœ“ Production image pushed to registry"

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # ============================================
  # JOB 6: Deploy to Production (Local)
  # ============================================
  deploy:
    name: Deploy Locally
    runs-on: self-hosted
    needs: push-production
    if: success()
    steps:
      - uses: actions/checkout@v4

      - name: Prepare deployment directory
        run: |
          sudo mkdir -p /opt/mood-classifier
          sudo chown -R $USER:$USER /opt/mood-classifier

      - name: Copy deployment files
        run: |
          cp docker-compose.prod.yml /opt/mood-classifier/
          cp fluent-bit.conf /opt/mood-classifier/

      - name: Deploy production stack
        run: |
          echo "ðŸš€ Deploying production stack locally"
          cd /opt/mood-classifier

          # Login to registry
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

          # Create volume if not exists
          docker volume create mood-data 2>/dev/null || true

          # Stop and remove old containers (including orphans)
          docker-compose -f docker-compose.prod.yml down --remove-orphans 2>/dev/null || true

          # Force remove any lingering containers with same names
          docker rm -f mood-classifier mood-arq-worker mood-redis fluent-bit 2>/dev/null || true

          # Pull latest image
          REGISTRY=${{ env.REGISTRY }} \
          REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }} \
          YC_LOG_GROUP_ID=${{ secrets.YC_LOG_GROUP_ID }} \
          YC_FOLDER_ID=${{ secrets.YC_FOLDER_ID }} \
          docker-compose -f docker-compose.prod.yml pull

          # Start services (app + arq-worker + redis + fluent-bit)
          REGISTRY=${{ env.REGISTRY }} \
          REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }} \
          YC_LOG_GROUP_ID=${{ secrets.YC_LOG_GROUP_ID }} \
          YC_FOLDER_ID=${{ secrets.YC_FOLDER_ID }} \
          docker-compose -f docker-compose.prod.yml up -d

          # Verify deployment
          sleep 5
          docker-compose -f docker-compose.prod.yml ps
          echo "âœ“ Deployment successful (app + arq-worker + redis + fluent-bit)"

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # ============================================
  # JOB 7: Cleanup Local Cache
  # ============================================
  cleanup:
    name: Cleanup Local Cache
    runs-on: self-hosted
    needs: [deploy]
    if: always()
    steps:
      - name: Clean old local test images
        run: |
          echo "ðŸ§¹ Cleaning old local test images (keeping last 2)"

          # Keep only last 2 test images
          docker images --format "{{.Repository}}:{{.Tag}}" | \
            grep "mood-classifier:test-" | \
            tail -n +3 | \
            xargs -r docker rmi -f || true

          # Prune dangling images
          docker image prune -f

          echo "âœ“ Cleanup complete"

      - name: Verify BuildKit cache size
        run: |
          if [ -d /tmp/.buildx-cache ]; then
            cache_size=$(du -sh /tmp/.buildx-cache | cut -f1)
            echo "ðŸ“Š BuildKit cache size: $cache_size"

            # Warn if cache is too large (>15GB)
            size_bytes=$(du -sb /tmp/.buildx-cache | cut -f1)
            if [ $size_bytes -gt 16000000000 ]; then
              echo "âš ï¸ Cache is very large (>15GB), consider clearing"
            fi
          fi

  # ============================================
  # JOB 8: Cleanup Old Registry Images
  # ============================================
  cleanup-registry:
    name: Cleanup Registry
    runs-on: self-hosted
    needs: [cleanup]
    if: always() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Install yc CLI
        run: |
          if ! command -v yc &> /dev/null; then
            curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
            source ~/.bashrc
          fi

      - name: Cleanup old images in registry (keep last 5)
        run: |
          echo "ðŸ§¹ Cleaning old images from registry (keeping last 5)"

          # List all images except latest
          yc container image list \
            --registry-id ${{ secrets.YC_REGISTRY_ID }} \
            --format json | \
          jq -r '.[] | select(.tags[] | contains("latest") | not) | .id' | \
          tail -n +6 | \
          while read image_id; do
            echo "Deleting image: $image_id"
            yc container image delete --id $image_id || true
          done

          echo "âœ“ Registry cleanup complete"
