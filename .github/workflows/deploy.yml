name: CI/CD Multi-Stage

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: cr.yandex
  REGISTRY_ID: crp78hhr2t67jkeedad1
  IMAGE_NAME: mood-classifier
  PYTHON_VERSION: "3.12"
  SHARED_BUILDER: ci-shared-builder
  GH_BIN: /opt/homebrew/bin/gh

jobs:
  # ===========================================================================
  # Job 1: Setup Shared Builder
  # ===========================================================================
  setup-builder:
    name: Setup Shared Builder
    runs-on: self-hosted
    steps:
      - name: Create or reuse shared builder
        run: |
          if ! docker buildx inspect ${{ env.SHARED_BUILDER }} >/dev/null 2>&1; then
            echo "Creating new shared builder: ${{ env.SHARED_BUILDER }}"
            docker buildx create \
              --name ${{ env.SHARED_BUILDER }} \
              --driver docker-container \
              --driver-opt network=host \
              --buildkitd-flags '--oci-worker-gc=false' \
              --bootstrap
          else
            echo "Shared builder already exists: ${{ env.SHARED_BUILDER }}"
          fi
          docker buildx use ${{ env.SHARED_BUILDER }}
          docker buildx inspect --bootstrap

  # ===========================================================================
  # Job 2: Security Scan
  # ===========================================================================
  security:
    name: Security Scan
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4

      - name: Cleanup gitleaks temp files
        run: rm -f /tmp/gitleaks.tmp /tmp/gitleaks_8.24.3_linux_x64.tar.gz
        continue-on-error: true

      - name: Run Gitleaks
        uses: gitleaks/gitleaks-action@v2
        continue-on-error: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_ENABLE_UPLOAD_ARTIFACT: false
          GITLEAKS_ENABLE_SUMMARY: false

  # ===========================================================================
  # Job 3: Build & Test
  # ===========================================================================
  build-and-test:
    name: Build & Test
    runs-on: self-hosted
    needs: setup-builder
    # Run immediately after setup-builder, don't wait for security
    steps:
      - uses: actions/checkout@v4

      - name: Login to registry (for cache pull only)
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login \
            ${{ env.REGISTRY }} \
            --username json_key \
            --password-stdin

      - name: Use shared builder
        run: docker buildx use ${{ env.SHARED_BUILDER }}

      - name: Pull previous image for layer cache
        run: |
          docker pull ${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest 2>/dev/null || \
          echo "No previous image, building from scratch"

      - name: Pull base image for cache
        run: |
          BASE_IMAGE="${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/app-base:${{ env.PYTHON_VERSION }}"
          docker pull "$BASE_IMAGE" 2>/dev/null || echo "Base image pull failed, will build from scratch"

      - name: Build test stage (includes app + test deps)
        run: |
          docker buildx build \
            --builder ${{ env.SHARED_BUILDER }} \
            --target test \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg REGISTRY=${{ env.REGISTRY }} \
            --build-arg REGISTRY_ID=${{ env.REGISTRY_ID }} \
            --cache-from type=registry,ref=${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache,mode=max \
            --output type=docker,name=mood-classifier:test-${{ github.sha }} \
            --file Dockerfile.unified \
            .

          echo "Test image built and loaded to Docker daemon"
          docker images | grep mood-classifier

      - name: Run container dependency tests
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            -e DATA_DIR=/data \
            -e DOWNLOADS_DIR=/tmp/downloads \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/test_ci_container.py -v --tb=short

      - name: Start Redis for integration tests
        run: |
          docker rm -f test-redis 2>/dev/null || true
          docker run -d --name test-redis -p 6379:6379 redis:7-alpine
          sleep 2

      - name: Run integration tests with Redis
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            --network host \
            -e REDIS_HOST=localhost \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/test_ci_cache_redis.py -v --tb=short

      - name: Run pipeline tests (real audio)
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            -v $(pwd)/tests/fixtures:/app/tests/fixtures \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/test_ci_pipelines.py -v --tb=short

      - name: Cleanup Redis
        if: always()
        run: docker rm -f test-redis 2>/dev/null || true

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }} || true

  # ===========================================================================
  # Job 4: Push Production Image
  # ===========================================================================
  push-production:
    name: Push Production Image
    runs-on: self-hosted
    needs: build-and-test
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Login to registry
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login \
            ${{ env.REGISTRY }} \
            --username json_key \
            --password-stdin

      - name: Use shared builder
        run: docker buildx use ${{ env.SHARED_BUILDER }}

      - name: Build production stage and push
        run: |
          echo "Building production stage (reuses layers from test build)"

          docker buildx build \
            --builder ${{ env.SHARED_BUILDER }} \
            --target production \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg REGISTRY=${{ env.REGISTRY }} \
            --build-arg REGISTRY_ID=${{ env.REGISTRY_ID }} \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --push \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            --file Dockerfile.unified \
            .

          echo "Production image pushed to registry"

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }} || true

  # ===========================================================================
  # Job 5: Cleanup Local Cache
  # ===========================================================================
  cleanup:
    name: Cleanup Local Cache
    runs-on: self-hosted
    needs: [push-production]
    if: always()
    steps:
      - name: Clean old local test images
        run: |
          echo "Cleaning old local test images (keeping last 2)"

          docker images --format "{{.Repository}}:{{.Tag}}" | \
            grep "mood-classifier:test-" | \
            tail -n +3 | \
            xargs -r docker rmi -f || true

          docker image prune -f

          echo "Cleanup complete"

      - name: Verify BuildKit cache size
        run: |
          if [ -d /tmp/.buildx-cache ]; then
            cache_size=$(du -sh /tmp/.buildx-cache | cut -f1)
            echo "BuildKit cache size: $cache_size"

            size_bytes=$(du -sb /tmp/.buildx-cache | cut -f1)
            if [ $size_bytes -gt 16000000000 ]; then
              echo "Cache is very large (>15GB), consider clearing"
            fi
          fi

  # ===========================================================================
  # Job 6: Deploy to VM
  # ===========================================================================
  deploy:
    name: Deploy to VM
    runs-on: self-hosted
    needs: push-production
    # No conditional - fetch-secrets.sh has built-in defaults
    steps:
      - uses: actions/checkout@v4

      - name: Fetch secrets from Lockbox
        run: |
          # Use fetch-secrets.sh script (has built-in defaults)
          if [ -f "./scripts/fetch-secrets.sh" ]; then
            chmod +x ./scripts/fetch-secrets.sh
            ./scripts/fetch-secrets.sh --env-file /home/ubuntu/app/.env
          else
            echo "ERROR: scripts/fetch-secrets.sh not found"
            exit 1
          fi

      - name: Login to YC registry
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login \
            ${{ env.REGISTRY }} \
            --username json_key \
            --password-stdin

      - name: Deploy containers
        run: |
          echo "=== Deploying containers ==="

          # Pull new image (YC registry only, no Docker Hub fallback)
          docker pull ${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest

          # Stop and remove old containers
          docker stop mood-classifier mood-arq-worker 2>/dev/null || true
          docker rm mood-classifier mood-arq-worker 2>/dev/null || true

          # Start bot container with env file from Lockbox
          docker run -d \
            --name mood-classifier \
            --restart unless-stopped \
            --network host \
            -v mood-data:/data \
            --env-file /home/ubuntu/app/.env \
            --health-cmd="python -c 'import sys; sys.exit(0)'" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-start-period=10s \
            --health-retries=3 \
            ${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            python -m app.main

          # Start ARQ worker container
          docker run -d \
            --name mood-arq-worker \
            --restart unless-stopped \
            --network host \
            -v mood-data:/data \
            --env-file /home/ubuntu/app/.env \
            --health-cmd="python -c 'import sys; sys.exit(0)'" \
            --health-interval=30s \
            --health-timeout=10s \
            --health-start-period=10s \
            --health-retries=3 \
            ${{ env.REGISTRY }}/${{ env.REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            arq app.services.arq_worker.WorkerSettings

          # Verify containers are running
          sleep 5
          docker ps | grep -E "mood-classifier|mood-arq-worker"

          # Check logs for startup errors
          echo ""
          echo "=== Bot startup logs ==="
          docker logs mood-classifier --tail 20

          echo ""
          echo "âœ… Deployment successful"

  # ===========================================================================
  # Job 7: Cleanup VM Trash Files
  # ===========================================================================
  cleanup-vm:
    name: Cleanup VM Trash Files
    runs-on: self-hosted
    needs: deploy
    if: always()
    steps:
      - name: Cleanup trash files on VM
        run: |
          echo "ðŸ§¹ Cleaning up trash files on VM..."

          # Remove old Docker logs (>2 days)
          find /var/lib/docker/containers -name "*.log" -mtime +2 -delete 2>/dev/null || true

          # Clean Docker system (unused images, containers, networks)
          docker system prune -f --volumes || true

          # Clean package cache
          sudo apt-get clean 2>/dev/null || true

          echo "âœ… VM cleanup complete"

  # ===========================================================================
  # Job 8: Cleanup Registry
  # ===========================================================================
  cleanup-registry:
    name: Cleanup Registry
    runs-on: self-hosted
    needs: [cleanup, cleanup-vm]
    if: always() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Cleanup old images in registry (keep last 5)
        run: |
          echo "Cleaning old images from registry (keeping last 5)"

          # Check if yc is available
          if ! command -v yc &> /dev/null; then
            echo "yc CLI not found, skipping registry cleanup"
            exit 0
          fi

          yc container image list \
            --registry-id ${{ env.REGISTRY_ID }} \
            --format json 2>/dev/null | \
          jq -r '.[] | select(.tags | length == 0 or (.[0] | contains("latest") | not)) | .id' | \
          tail -n +6 | \
          while read image_id; do
            if [ -n "$image_id" ]; then
              echo "Deleting image: $image_id"
              yc container image delete --id "$image_id" 2>/dev/null || true
            fi
          done

          echo "Registry cleanup complete"
