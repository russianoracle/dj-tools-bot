name: CI/CD Multi-Stage

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:

env:
  REGISTRY: cr.yandex
  IMAGE_NAME: mood-classifier
  PYTHON_VERSION: "3.12"
  SHARED_BUILDER: ci-shared-builder

jobs:
  # ============================================
  # JOB 1: Setup Shared Builder (idempotent)
  # ============================================
  setup-builder:
    name: Setup Shared Builder
    runs-on: self-hosted
    steps:
      - name: Create or reuse shared builder
        run: |
          if ! docker buildx inspect ${{ env.SHARED_BUILDER }} >/dev/null 2>&1; then
            echo "ðŸ”§ Creating new shared builder: ${{ env.SHARED_BUILDER }}"
            docker buildx create \
              --name ${{ env.SHARED_BUILDER }} \
              --driver docker-container \
              --driver-opt network=host \
              --buildkitd-flags '--oci-worker-gc=false' \
              --bootstrap
          else
            echo "âœ“ Shared builder already exists: ${{ env.SHARED_BUILDER }}"
          fi
          docker buildx use ${{ env.SHARED_BUILDER }}
          docker buildx inspect --bootstrap

  # ============================================
  # JOB 2: Security Scan
  # ============================================
  security:
    name: Security Scan
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install Gitleaks
        run: |
          if ! command -v gitleaks &> /dev/null; then
            echo "ðŸ“¥ Installing gitleaks..."
            wget -q https://github.com/gitleaks/gitleaks/releases/download/v8.18.4/gitleaks_8.18.4_linux_x64.tar.gz
            tar -xzf gitleaks_8.18.4_linux_x64.tar.gz -C /tmp
            sudo mv /tmp/gitleaks /usr/local/bin/
            rm gitleaks_8.18.4_linux_x64.tar.gz
          fi
          gitleaks version

      - name: Run Gitleaks scan
        continue-on-error: true
        run: |
          echo "ðŸ” Scanning for secrets..."
          gitleaks detect --source . --verbose --no-git --exit-code 0
          echo "âœ… Security scan completed"

  # ============================================
  # JOB 3: Build & Test (LOCAL ONLY, NO PUSH)
  # ============================================
  build-and-test:
    name: Build & Test
    runs-on: self-hosted
    needs: [setup-builder]
    # Security scan is optional - don't block build if it fails
    steps:
      - uses: actions/checkout@v4

      - name: Login to registry (for cache pull only)
        run: echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

      - name: Use shared builder
        run: docker buildx use ${{ env.SHARED_BUILDER }}

      - name: Pull previous image for layer cache
        run: |
          docker pull ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest 2>/dev/null || \
          echo "âš ï¸ No previous image, building from scratch"

      - name: Pull base image for cache
        run: |
          BASE_IMAGE="${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/python-scientific:${{ env.PYTHON_VERSION }}"

          echo "ðŸ”„ Pulling latest base image: $BASE_IMAGE"
          docker pull "$BASE_IMAGE" 2>/dev/null || echo "âš ï¸ Base image pull failed, will build from scratch"

          # Show base image creation date to verify freshness
          if docker image inspect "$BASE_IMAGE" >/dev/null 2>&1; then
            CREATED=$(docker inspect "$BASE_IMAGE" --format='{{.Created}}')
            echo "ðŸ“… Base image created: $CREATED"
          fi

      - name: Build test stage (includes app + test deps)
        run: |
          docker buildx build \
            --builder ${{ env.SHARED_BUILDER }} \
            --target test \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg REGISTRY=${{ env.REGISTRY }} \
            --build-arg REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }} \
            --cache-from type=registry,ref=${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --cache-to type=local,dest=/tmp/.buildx-cache,mode=max \
            --output type=docker,name=mood-classifier:test-${{ github.sha }} \
            --file Dockerfile.unified \
            .

          echo "âœ“ Test image built and loaded to Docker daemon"
          docker images | grep mood-classifier

      - name: Run unit tests
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/ -m "unit" -vv --tb=short

      - name: Start Redis for integration tests
        run: |
          docker run -d --name test-redis -p 6379:6379 redis:7-alpine
          sleep 2

      - name: Run integration tests with Redis
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            --network host \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/ -m "integration" -vv --tb=short

      - name: Run analysis tests (real audio)
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            mood-classifier:test-${{ github.sha }} \
            pytest tests/ -m "analysis" -vv --tb=short

      - name: Cleanup Redis
        if: always()
        run: docker rm -f test-redis || true

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # ============================================
  # JOB 4: Build & Push Production (AFTER TESTS)
  # ============================================
  push-production:
    name: Push Production Image
    runs-on: self-hosted
    needs: build-and-test
    if: success() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - uses: actions/checkout@v4

      - name: Login to registry
        run: echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

      - name: Use shared builder
        run: docker buildx use ${{ env.SHARED_BUILDER }}

      - name: Build production stage and push
        run: |
          echo "ðŸš€ Building production stage (reuses layers from test build)"

          docker buildx build \
            --builder ${{ env.SHARED_BUILDER }} \
            --target production \
            --build-arg PYTHON_VERSION=${{ env.PYTHON_VERSION }} \
            --build-arg REGISTRY=${{ env.REGISTRY }} \
            --build-arg REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }} \
            --cache-from type=local,src=/tmp/.buildx-cache \
            --push \
            -t ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }} \
            -t ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest \
            --file Dockerfile.unified \
            .

          echo "âœ“ Production image pushed to registry"

      - name: Logout from registry
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # ============================================
  # JOB 5: Deploy to Production VM
  # ============================================
  deploy:
    name: Deploy to VM
    runs-on: self-hosted
    needs: push-production
    if: success()
    steps:
      - uses: actions/checkout@v4

      - name: Setup SSH key
        env:
          SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
        run: |
          mkdir -p ~/.ssh
          echo "$SSH_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key
          ssh-keyscan -H 158.160.122.216 >> ~/.ssh/known_hosts

      - name: Prepare deployment directory on VM
        run: |
          ssh -i ~/.ssh/deploy_key ubuntu@158.160.122.216 "mkdir -p /opt/mood-classifier"

      - name: Copy deployment files to VM
        run: |
          scp -i ~/.ssh/deploy_key docker-compose.prod.yml ubuntu@158.160.122.216:/opt/mood-classifier/
          scp -i ~/.ssh/deploy_key fluent-bit.conf ubuntu@158.160.122.216:/opt/mood-classifier/

      - name: Deploy to production VM
        env:
          YC_SA_KEY: ${{ secrets.YC_SA_JSON_KEY }}
        run: |
          echo "ðŸš€ Deploying to production VM: 158.160.122.216"

          ssh -i ~/.ssh/deploy_key ubuntu@158.160.122.216 << 'EOF'
            cd /opt/mood-classifier || (mkdir -p /opt/mood-classifier && cd /opt/mood-classifier)

            # Login to registry
            echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

            # Create volume if not exists
            docker volume create mood-data 2>/dev/null || true

            # Stop and remove old containers
            docker-compose -f docker-compose.prod.yml down 2>/dev/null || true

            # Pull latest image
            REGISTRY=${{ env.REGISTRY }} \
            REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }} \
            YC_LOG_GROUP_ID=${{ secrets.YC_LOG_GROUP_ID }} \
            YC_FOLDER_ID=${{ secrets.YC_FOLDER_ID }} \
            docker-compose -f docker-compose.prod.yml pull

            # Start services
            REGISTRY=${{ env.REGISTRY }} \
            REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }} \
            YC_LOG_GROUP_ID=${{ secrets.YC_LOG_GROUP_ID }} \
            YC_FOLDER_ID=${{ secrets.YC_FOLDER_ID }} \
            docker-compose -f docker-compose.prod.yml up -d

            # Verify deployment
            sleep 5
            docker-compose -f docker-compose.prod.yml ps
            echo "âœ“ Deployment successful (app + fluent-bit for Yandex Cloud Logging)"
          EOF

      - name: Cleanup SSH key
        if: always()
        run: rm -f ~/.ssh/deploy_key

  # ============================================
  # JOB 6: Cleanup Local Cache
  # ============================================
  cleanup:
    name: Cleanup Local Cache
    runs-on: self-hosted
    needs: [push-production]
    if: always()
    steps:
      - name: Clean old local test images
        run: |
          echo "ðŸ§¹ Cleaning old local test images (keeping last 2)"

          # Keep only last 2 test images
          docker images --format "{{.Repository}}:{{.Tag}}" | \
            grep "mood-classifier:test-" | \
            tail -n +3 | \
            xargs -r docker rmi -f || true

          # Prune dangling images
          docker image prune -f

          echo "âœ“ Cleanup complete"

      - name: Verify BuildKit cache size
        run: |
          if [ -d /tmp/.buildx-cache ]; then
            cache_size=$(du -sh /tmp/.buildx-cache | cut -f1)
            echo "ðŸ“Š BuildKit cache size: $cache_size"

            # Warn if cache is too large (>15GB)
            size_bytes=$(du -sb /tmp/.buildx-cache | cut -f1)
            if [ $size_bytes -gt 16000000000 ]; then
              echo "âš ï¸ Cache is very large (>15GB), consider clearing"
            fi
          fi

  # ============================================
  # JOB 7: Cleanup Old Registry Images
  # ============================================
  cleanup-registry:
    name: Cleanup Registry
    runs-on: self-hosted
    needs: [cleanup]
    if: always() && github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Install yc CLI
        run: |
          if ! command -v yc &> /dev/null; then
            curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash
            source ~/.bashrc
          fi

      - name: Cleanup old images in registry (keep last 5)
        run: |
          echo "ðŸ§¹ Cleaning old images from registry (keeping last 5)"

          # List all images except latest
          yc container image list \
            --registry-id ${{ secrets.YC_REGISTRY_ID }} \
            --format json | \
          jq -r '.[] | select(.tags[] | contains("latest") | not) | .id' | \
          tail -n +6 | \
          while read image_id; do
            echo "Deleting image: $image_id"
            yc container image delete --id $image_id || true
          done

          echo "âœ“ Registry cleanup complete"
