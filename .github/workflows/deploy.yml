name: CI/CD

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]
  workflow_dispatch:
    inputs:
      use_selfhosted:
        description: 'Use self-hosted runner'
        required: false
        default: 'false'
        type: choice
        options:
          - 'true'
          - 'false'

env:
  REGISTRY: cr.yandex
  IMAGE_NAME: mood-classifier
  PYTHON_VERSION: "3.12"
  # Toggle self-hosted runner: 'self-hosted' or 'ubuntu-latest'
  RUNNER_TYPE: ${{ github.event.inputs.use_selfhosted == 'true' && 'self-hosted' || 'ubuntu-latest' }}

jobs:
  # =============================================================================
  # STAGE 1A: Check if base image needs rebuild
  # =============================================================================
  check-base-image:
    name: Check Base Image
    runs-on: ubuntu-latest
    outputs:
      needs-rebuild: ${{ steps.check.outputs.needs-rebuild }}
      deps-hash: ${{ steps.check.outputs.deps-hash }}
      base-exists: ${{ steps.check-registry.outputs.exists }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 2

      - name: Calculate dependencies hash
        id: check
        run: |
          # Ğ’Ñ‹Ñ‡Ğ¸ÑĞ»ÑĞµĞ¼ hash Ğ·Ğ°Ğ²Ğ¸ÑĞ¸Ğ¼Ğ¾ÑÑ‚ĞµĞ¹ Ğ±Ğ°Ğ·Ğ¾Ğ²Ğ¾Ğ³Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ°
          DEPS_HASH=$(grep -E '(numpy|scipy|scikit-learn|pandas|numba|essentia-tensorflow)' Dockerfile.base | md5sum | cut -d' ' -f1)
          echo "deps-hash=$DEPS_HASH" >> $GITHUB_OUTPUT
          echo "ğŸ“Š Base image dependencies hash: $DEPS_HASH"

          # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»ÑÑ Ğ»Ğ¸ Dockerfile.base
          if git diff --name-only HEAD~1 HEAD | grep -E '^(Dockerfile\.base)$'; then
            echo "needs-rebuild=true" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Dockerfile.base changed - rebuild required"
          else
            echo "needs-rebuild=false" >> $GITHUB_OUTPUT
            echo "âœ“ Dockerfile.base unchanged"
          fi

      - name: Login to registry
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

      - name: Check if base image exists in registry
        id: check-registry
        run: |
          DEPS_HASH="${{ steps.check.outputs.deps-hash }}"
          echo "ğŸ” Checking registry for base image with hash: $DEPS_HASH"

          # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ÑÑƒÑ‰ĞµÑÑ‚Ğ²Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‡ĞµÑ€ĞµĞ· docker manifest (Ğ±Ñ‹ÑÑ‚Ñ€ĞµĞµ Ñ‡ĞµĞ¼ pull)
          if docker manifest inspect ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/python-scientific:${{ env.PYTHON_VERSION }}-$DEPS_HASH >/dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
            echo "âœ“ Base image with matching dependencies found"
          else
            echo "exists=false" >> $GITHUB_OUTPUT
            echo "âŒ Base image not found - will need to build"
          fi

      - name: Logout
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # =============================================================================
  # STAGE 1B: Build base image if needed
  # =============================================================================
  build-base-image:
    name: Build Base Image
    runs-on: self-hosted
    needs: [check-base-image]
    # Ğ¡Ğ¾Ğ±Ğ¸Ñ€Ğ°ĞµĞ¼ ĞµÑĞ»Ğ¸: Dockerfile.base Ğ¸Ğ·Ğ¼ĞµĞ½Ğ¸Ğ»ÑÑ Ğ˜Ğ›Ğ˜ Ğ¾Ğ±Ñ€Ğ°Ğ·Ğ° Ñ Ğ½ÑƒĞ¶Ğ½Ñ‹Ğ¼ hash'Ğ¾Ğ¼ Ğ½ĞµÑ‚ Ğ² registry
    if: |
      needs.check-base-image.outputs.needs-rebuild == 'true' ||
      needs.check-base-image.outputs.base-exists == 'false'
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Yandex Container Registry
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

      - name: Build and push base image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.base
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/python-scientific:${{ env.PYTHON_VERSION }}
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/python-scientific:${{ env.PYTHON_VERSION }}-${{ needs.check-base-image.outputs.deps-hash }}
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/python-scientific:latest
          cache-from: type=registry,ref=${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/python-scientific:buildcache
          cache-to: type=registry,ref=${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/python-scientific:buildcache,mode=max
          build-args: |
            PYTHON_VERSION=${{ env.PYTHON_VERSION }}

      - name: Logout
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # =============================================================================
  # STAGE 1C: Build Production Image (Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ÑÑ Ğ´Ğ»Ñ Ñ‚ĞµÑÑ‚Ğ¾Ğ² Ğ¸ Ğ´ĞµĞ¿Ğ»Ğ¾Ñ)
  # =============================================================================
  build-prod-image:
    name: Build Prod Image
    runs-on: self-hosted
    needs: [check-base-image, build-base-image]
    if: always() && (needs.check-base-image.result == 'success')
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Generate image metadata
        id: meta
        run: |
          echo "tags=test-${{ github.sha }}" >> $GITHUB_OUTPUT
          echo "Image will be tagged as: test-${{ github.sha }}"

      - name: Login to Yandex Container Registry
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

      - name: Pull base image if needed
        run: |
          # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ ĞµÑÑ‚ÑŒ Ğ»Ğ¸ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ· Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾
          BASE_IMAGE="${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/python-scientific:${{ env.PYTHON_VERSION }}"

          if docker image inspect "$BASE_IMAGE" >/dev/null 2>&1; then
            echo "âœ“ Base image found in local cache"
          else
            echo "âŒ Base image not in local cache, pulling from registry..."
            docker pull "$BASE_IMAGE" || echo "âš ï¸ Failed to pull base image, will build from scratch"
          fi

      - name: Decide which Dockerfile to use
        id: dockerfile
        run: |
          # Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµĞ¼ fast ĞµÑĞ»Ğ¸ Ğ±Ğ°Ğ·Ğ¾Ğ²Ñ‹Ğ¹ Ğ¾Ğ±Ñ€Ğ°Ğ· ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚ Ğ˜Ğ›Ğ˜ Ğ±Ñ‹Ğ» Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ñ‡Ñ‚Ğ¾ ÑĞ¾Ğ±Ñ€Ğ°Ğ½
          if [ "${{ needs.check-base-image.outputs.base-exists }}" == "true" ] || [ "${{ needs.build-base-image.result }}" == "success" ]; then
            echo "file=Dockerfile.fast" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Using Dockerfile.fast (with base image)"
          else
            echo "file=Dockerfile" >> $GITHUB_OUTPUT
            echo "ğŸ“¦ Using Dockerfile (standalone)"
          fi

      - name: Build prod image (local only, no push)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./${{ steps.dockerfile.outputs.file }}
          push: false
          load: true
          tags: ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-${{ github.sha }}
          cache-from: |
            type=registry,ref=${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:buildcache
            type=registry,ref=${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest
            type=local,src=/tmp/.buildx-cache-prod
          cache-to: type=local,dest=/tmp/.buildx-cache-prod,mode=max
          build-args: |
            BUILDKIT_INLINE_CACHE=1
            PYTHON_VERSION=${{ env.PYTHON_VERSION }}
            REGISTRY=${{ env.REGISTRY }}
            REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }}

      - name: Verify prod image loaded to Docker
        run: |
          echo "=== Verifying prod image in Docker daemon ==="
          docker images | grep "${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}"

          # ĞŸÑ€Ğ¾Ğ²ĞµÑ€ÑĞµĞ¼ Ñ‡Ñ‚Ğ¾ Ğ¾Ğ±Ñ€Ğ°Ğ· ÑÑƒÑ‰ĞµÑÑ‚Ğ²ÑƒĞµÑ‚
          if ! docker image inspect "${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-${{ github.sha }}" >/dev/null 2>&1; then
            echo "âŒ Prod image NOT found in Docker daemon after build!"
            echo "Available images:"
            docker images
            exit 1
          fi
          echo "âœ… Prod image found in Docker daemon"

      - name: Logout
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # =============================================================================
  # STAGE 1D: Build Test Image (extends prod image with pytest)
  # =============================================================================
  build-test-image:
    name: Build Test Image
    runs-on: self-hosted
    needs: [build-prod-image]
    if: always() && (needs.build-prod-image.result == 'success')
    steps:
      - uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Login to Yandex Container Registry
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

      - name: Build test image (local only, no push)
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile.test
          push: false
          load: true
          tags: ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-with-pytest-${{ github.sha }}
          cache-from: |
            type=registry,ref=${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-buildcache
            type=local,src=/tmp/.buildx-cache
          cache-to: type=local,dest=/tmp/.buildx-cache,mode=max
          build-args: |
            REGISTRY=${{ env.REGISTRY }}
            REGISTRY_ID=${{ secrets.YC_REGISTRY_ID }}
            IMAGE_NAME=${{ env.IMAGE_NAME }}
            IMAGE_TAG=test-${{ github.sha }}

      - name: Logout
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # =============================================================================
  # STAGE 2: Security Scan (Ğ¿Ğ°Ñ€Ğ°Ğ»Ğ»ĞµĞ»ÑŒĞ½Ğ¾ Ñ build)
  # =============================================================================
  security:
    name: Security
    runs-on: self-hosted
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Check for secrets with Gitleaks
        uses: gitleaks/gitleaks-action@v2
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITLEAKS_ENABLE_UPLOAD_ARTIFACT: false
          GITLEAKS_ENABLE_SUMMARY: false

  # =============================================================================
  # STAGE 3: Unit Tests (Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Docker image Ğ¸Ğ· build-test-image)
  # =============================================================================
  test-unit:
    name: Unit Tests
    runs-on: self-hosted
    needs: [build-test-image]
    if: always() && (needs.build-test-image.result == 'success')
    steps:
      - uses: actions/checkout@v4

      - name: Run unit tests in container
        run: |
          # ĞĞ±Ñ€Ğ°Ğ· ÑƒĞ¶Ğµ Ğ½Ğ° runner Ğ¿Ğ¾ÑĞ»Ğµ build-test-image (Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ĞºÑÑˆ)
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-with-pytest-${{ github.sha }} \
            pytest tests/ -m "unit" -vv --tb=short

  # =============================================================================
  # STAGE 4: Integration Tests Ñ Redis (Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Docker image)
  # =============================================================================
  test-integration-redis:
    name: Integration Tests (Redis)
    runs-on: self-hosted
    needs: [build-test-image]
    if: always() && (needs.build-test-image.result == 'success')
    services:
      redis:
        image: redis:7-alpine
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379

    steps:
      - uses: actions/checkout@v4

      - name: Run bot component tests
        run: |
          # ĞĞ±Ñ€Ğ°Ğ· ÑƒĞ¶Ğµ Ğ½Ğ° runner Ğ¿Ğ¾ÑĞ»Ğµ build-test-image (Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ĞºÑÑˆ)
          docker run --rm \
            --network host \
            -e REDIS_URL=redis://localhost:6379/0 \
            -v $(pwd)/tests:/app/tests \
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-with-pytest-${{ github.sha }} \
            pytest tests/test_ci_bot.py -vv --tb=short

      - name: Run Redis cache integration tests
        run: |
          docker run --rm \
            --network host \
            -e REDIS_URL=redis://localhost:6379/0 \
            -v $(pwd)/tests:/app/tests \
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-with-pytest-${{ github.sha }} \
            pytest tests/test_ci_cache_redis.py -vv --tb=short

  # =============================================================================
  # STAGE 5: Pipeline Tests (Ğ¸ÑĞ¿Ğ¾Ğ»ÑŒĞ·ÑƒĞµÑ‚ Docker image)
  # =============================================================================
  test-pipelines:
    name: Pipeline Tests (Real Audio)
    runs-on: self-hosted
    needs: [build-test-image]
    if: always() && (needs.build-test-image.result == 'success')
    steps:
      - uses: actions/checkout@v4

      - name: Verify test audio files exist
        run: |
          echo "=== Checking Test Audio Files ==="
          ls -lh tests/fixtures/audio/
          test -f tests/fixtures/audio/track_sample_30s.flac || exit 1
          test -f tests/fixtures/audio/set_sample_30s.m4a || exit 1

      - name: Run TrackAnalysisPipeline tests
        run: |
          # ĞĞ±Ñ€Ğ°Ğ· ÑƒĞ¶Ğµ Ğ½Ğ° runner Ğ¿Ğ¾ÑĞ»Ğµ build-test-image (Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ñ‹Ğ¹ ĞºÑÑˆ)
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-with-pytest-${{ github.sha }} \
            pytest tests/test_ci_pipelines.py::TestTrackAnalysisPipeline -vv --tb=short

      - name: Run SetAnalysisPipeline tests
        run: |
          docker run --rm \
            -v $(pwd)/tests:/app/tests \
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-with-pytest-${{ github.sha }} \
            pytest tests/test_ci_pipelines.py::TestSetAnalysisPipeline -vv --tb=short

  # =============================================================================
  # STAGE 6: Push Images to Registry (AFTER tests pass!)
  # =============================================================================
  push-to-registry:
    name: Push to Registry
    runs-on: self-hosted
    needs: [security, test-unit, test-integration-redis, test-pipelines]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Login to registry
        run: echo '${{ secrets.YC_SA_JSON_KEY }}' | docker login ${{ env.REGISTRY }} --username json_key --password-stdin

      - name: Tag and push prod image
        run: |
          # ĞĞ±Ñ€Ğ°Ğ· ÑƒĞ¶Ğµ ĞµÑÑ‚ÑŒ Ğ»Ğ¾ĞºĞ°Ğ»ÑŒĞ½Ğ¾ Ğ¿Ğ¾ÑĞ»Ğµ Ğ±Ğ¸Ğ»Ğ´Ğ° (Ñ Ñ‚ĞµĞ³Ğ¾Ğ¼ test-SHA)
          docker tag ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-${{ github.sha }} \
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          docker tag ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-${{ github.sha }} \
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest

          docker push ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:${{ github.sha }}
          docker push ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:latest

      - name: Update registry cache
        run: |
          # ĞŸÑƒÑˆĞ¸Ğ¼ Ğ² registry cache Ğ´Ğ»Ñ ÑĞ»ĞµĞ´ÑƒÑÑ‰Ğ¸Ñ… Ğ±Ğ¸Ğ»Ğ´Ğ¾Ğ²
          docker tag ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-${{ github.sha }} \
            ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:buildcache
          docker push ${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:buildcache || true

      - name: Logout
        if: always()
        run: docker logout ${{ env.REGISTRY }}

  # =============================================================================
  # STAGE 7: Cleanup Local Docker Cache (keep last 2 builds)
  # =============================================================================
  cleanup-local-cache:
    name: Cleanup Local Cache
    runs-on: self-hosted
    needs: push-to-registry
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Clean old Docker images
        run: |
          echo "=== Cleaning old Docker images (keeping last 2) ==="

          # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ test-* Ğ¾Ğ±Ñ€Ğ°Ğ·Ñ‹ (Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 2)
          docker images --format "{{.Repository}}:{{.Tag}}" | \
            grep "${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-" | \
            tail -n +3 | \
            xargs -r docker rmi -f || true

          # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ ÑÑ‚Ğ°Ñ€Ñ‹Ğµ test-with-pytest-* Ğ¾Ğ±Ñ€Ğ°Ğ·Ñ‹ (Ğ¾ÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ 2)
          docker images --format "{{.Repository}}:{{.Tag}}" | \
            grep "${{ env.REGISTRY }}/${{ secrets.YC_REGISTRY_ID }}/${{ env.IMAGE_NAME }}:test-with-pytest-" | \
            tail -n +3 | \
            xargs -r docker rmi -f || true

          # Ğ£Ğ´Ğ°Ğ»ÑĞµĞ¼ dangling images
          docker image prune -f

          echo "âœ“ Local cache cleanup complete"

      - name: Clean old BuildKit cache
        run: |
          echo "=== Cleaning old BuildKit cache ==="

          # ĞÑÑ‚Ğ°Ğ²Ğ»ÑĞµĞ¼ Ñ‚Ğ¾Ğ»ÑŒĞºĞ¾ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğµ Ñ„Ğ°Ğ¹Ğ»Ñ‹ Ğ² ĞºÑÑˆĞµ (Ğ¿Ğ¾ Ğ´Ğ°Ñ‚Ğµ Ğ¼Ğ¾Ğ´Ğ¸Ñ„Ğ¸ĞºĞ°Ñ†Ğ¸Ğ¸)
          find /tmp/.buildx-cache-prod -type f -mtime +7 -delete 2>/dev/null || true
          find /tmp/.buildx-cache -type f -mtime +7 -delete 2>/dev/null || true

          echo "âœ“ BuildKit cache cleanup complete"

  # =============================================================================
  # STAGE 8: Cleanup Old Images Ğ² Registry
  # =============================================================================
  cleanup-registry:
    name: Cleanup Registry
    runs-on: self-hosted
    needs: cleanup-local-cache
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Install yc CLI
        run: |
          curl -sSL https://storage.yandexcloud.net/yandexcloud-yc/install.sh | bash -s -- -n -i /opt/yc
          echo "/opt/yc/bin" >> $GITHUB_PATH

      - name: Configure yc CLI
        run: |
          echo '${{ secrets.YC_SA_JSON_KEY }}' > /tmp/sa-key.json
          /opt/yc/bin/yc config set service-account-key /tmp/sa-key.json
          /opt/yc/bin/yc config set folder-id ${{ secrets.YC_FOLDER_ID }}

      - name: Delete old images (keep latest 5)
        run: |
          IMAGES=$(/opt/yc/bin/yc container image list --repository-name=${{ secrets.YC_REGISTRY_ID }}/mood-classifier --format=json | jq -r 'sort_by(.createdAt) | reverse | .[5:] | .[].id')
          for IMAGE_ID in $IMAGES; do
            echo "Deleting old image: $IMAGE_ID"
            /opt/yc/bin/yc container image delete --id=$IMAGE_ID || true
          done

      - name: Cleanup
        if: always()
        run: rm -f /tmp/sa-key.json

  # =============================================================================
  # STAGE 8: Deploy Ğ½Ğ° VM
  # =============================================================================
  deploy:
    name: Deploy to VM
    runs-on: self-hosted
    needs: push-to-registry
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    steps:
      - name: Deploy via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          YC_REGISTRY_ID: ${{ secrets.YC_REGISTRY_ID }}
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          ADMIN_USER_ID: ${{ secrets.ADMIN_USER_ID }}
          YC_SA_JSON_KEY: ${{ secrets.YC_SA_JSON_KEY }}
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_PRIVATE_KEY }}
          envs: YC_REGISTRY_ID,TELEGRAM_BOT_TOKEN,ADMIN_USER_ID,YC_SA_JSON_KEY
          script: |
            cd ~/app

            # Login to Yandex Container Registry
            echo "$YC_SA_JSON_KEY" | docker login cr.yandex --username json_key --password-stdin

            # Pull latest image
            docker pull cr.yandex/$YC_REGISTRY_ID/mood-classifier:latest

            # Export env vars for docker-compose
            export YC_REGISTRY_ID=$YC_REGISTRY_ID
            export TELEGRAM_BOT_TOKEN=$TELEGRAM_BOT_TOKEN
            export ADMIN_USER_ID=$ADMIN_USER_ID

            # Stop old containers, start new
            docker compose down || docker-compose down || true
            docker compose up -d || docker-compose up -d

            # Cleanup
            docker logout cr.yandex
            docker image prune -af

            # Show status
            docker ps
            docker logs mood-classifier-bot --tail 20 2>&1 || docker logs dj-tools-bot --tail 20 2>&1 || true
